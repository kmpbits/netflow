package com.kmpbits.netflow_core.builders

import com.kmpbits.netflow_core.alias.Header
import com.kmpbits.netflow_core.alias.Headers
import com.kmpbits.netflow_core.alias.Parameter
import com.kmpbits.netflow_core.alias.Parameters
import com.kmpbits.netflow_core.annotations.NetFlowMarker
import com.kmpbits.netflow_core.enums.HttpHeader
import com.kmpbits.netflow_core.enums.HttpMethod
import com.kmpbits.netflow_core.exceptions.NetFlowException
import com.kmpbits.netflow_core.platform.InternalHttpRequestBuilder

@NetFlowMarker
class RequestBuilder internal constructor(
    internal val baseUrl: String,
    internal val retryBuilder: RetryBuilder,
    internal val headers: Headers
) {

    @PublishedApi
    internal var preCall: (() -> Unit)? = null

    internal val parameters: Parameters = mutableListOf()

    internal var body: Map<String, Any>? = null

    /**
     * The method of the request.
     * @see [HttpMethod]
     */
    var method: HttpMethod = HttpMethod.Get

    /**
     * The partial url of this particular request.
     * It will be joined into base url.
     */
    var path: String = ""

    /**
     * Call this method if you want to do something before the request starts
     *
     */
    fun preCall(call: () -> Unit) {
        this.preCall = call
    }

    fun updateParameter(key: String, value: Any): Parameter {
        val existParameter = parameterByKey(key)

        if (existParameter == null)
            parameters.add(Parameter(key, value))

        val newParameter = Parameter(key, value)

        existParameter?.let {
            parameters.remove(it)
            parameters.add(newParameter)
        }

        return newParameter
    }

    /**
     * The [Header] object to send in the http request in this particular request.
     *
     * @param header The header to send.
     */
    fun header(header: Header) {
        if (headers.contains(header).not())
            headers.add(header)
    }

    /**
     * Authorization header to to send in the http request for this particular request.
     *
     * @param token The token generated by the api server.
     * @param prefix That is used to the header. Default is 'Bearer'.
     */
    fun authorization(token: String?, prefix: String = "Bearer") {
        if (hasHeader(HttpHeader.AUTHORIZATION).not()) {
            val header = Header(HttpHeader.AUTHORIZATION, "$prefix $token")
            headers.add(header)
        }
    }

    /**
     * The language that will be used in the server to get the response for this particular request.
     *
     * @param languageCode Should have 2 characters only.
     * If you already sent the language, this will be ignored.
     */
    fun language(languageCode: String) {
        if (languageCode.length > 2 || languageCode.length < 2)
            throw NetFlowException("Language code must contains only 2 characters")

        if (hasHeader(HttpHeader.ACCEPT_LANGUAGE).not()) {
            val header = Header(HttpHeader.ACCEPT_LANGUAGE, languageCode)
            headers.add(header)
        }
    }

    /**
     * The query parameter of the request.
     *
     * If you already sent the same parameter, this will be ignored.
     *
     * @param parameter Key-value parameter to send
     */
    fun parameter(parameter: Parameter) {
        if (parameters.contains(parameter).not())
            parameters.add(parameter)
    }

    /**
     * The query parameter of the request.
     * This functions allows to send a value in a [List]
     *
     * If you already sent the same parameter [key], this will be ignored.
     *
     * @param key
     * @param value
     */
    fun parameter(key: String, value: List<Any>) {
        value.forEach {
            val parameter = Parameter(key, it)
            parameter(parameter)
        }
    }

    /**
     * The body parameter of the request.
     * This should be used only with [HttpMethod.Post]
     *
     * @param body the object of type [Map<String, Any>] to send
     */
    fun body(body: Map<String, Any>) {
        this.body = body
    }

    /**
     * Configures retry behavior specifically for this request.
     *
     * This local configuration **overrides** any global retry settings defined
     * in [netFlowClient].
     *
     * Use it to customize the number of attempts, delay between retries, and
     * conditional logic to determine if an exception should trigger a retry,
     * allowing fine-grained control per call.
     *
     * Example:
     * ```
     * client.call {
     *     GET("/posts")
     *     retry {
     *         times = 4
     *         delay = 500.milliseconds
     *         retryOn = { it is IOException }
     *     }
     * }
     * ```
     *
     * @param block Lambda with receiver on [RetryBuilder] to configure retry options.
     */
    fun retry(builder: RetryBuilder. () -> Unit) {
        retryBuilder.also(builder)
    }

    private fun parameterByKey(key: String) = parameters.find { it.first == key }

    private fun hasHeader(key: HttpHeader) = headers.find { it.first == key } != null
}

internal expect fun RequestBuilder.build(): InternalHttpRequestBuilder